[TOC]

##### 1.new和malloc的区别：

(1)  new是运算符，malloc是库函数

(2)  new会调用构造函数对对象进行初始化，malloc不会。

(3)  new申请分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显示地指出所需内存的尺寸。

(4)  new分配内存成功后返回指定的对象类型的指针，malloc返回void*。

(5)  new分配内存失败，会抛出bad_malloc异常，malloc分配内存失败会返回空指针。

new分配的内存通过delete释放，malloc分配的内存通过调用free()函数释放

##### 2.C语言程序能不能直接调用C++语言编写的动态链接库。

不能，因为C++支持重载，在编译函数的声明时，会改写函数名（可以通过链接指示进行解决）；另外，C语言不支持类，无法直接调用类的成员函数（可以通过加入中间层进行解决）；C语言也不能调用返回类型或形参类型是类类型的函数。

##### 3.关键字static的作用

（1）定义静态局部变量：在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。

（2）定义static全局变量：static全局变量仅在本文件内有效

（3）定义static函数：static函数仅在本文件内有效

（4）定义静态数据成员：静态成员数据成员与类本身相关联，而不是与类的各个对象保持关联。对象中不包含任何与静态数据成员有关的数据。

（5）定义静态成员函数：静态成员函数不与任何对象绑定在一起，它们不包含this指针。作为结果，静态成员函数不能声明成const的，而且我们也不能在static函数体内显式或隐式地使用this指针。

##### 4.const关键字的作用

（1）定义const对象，阻止变量的值被改变，const对象必须被初始化（因为它的值不能被改变）。

（2）定义常量引用，常量引用不能用于修改它所绑定的对象。

（3）定义常量指针，常量指针是指指针本身是常量，常量指针必须初始化，而且一旦初始化，则它的值就不能改变了。Const在*左边

（4）定义指向常量的指针，指向常量的指针不能用于改变它所指对象的值。

（5）定义const成员函数，常量对象，常量对象的引用或指针都只能调用常量成员函数。

（6）定义函数的形参为常量引用，表明函数不会修改实参的值，同时，也能使用const对象，字面值或者需要类型转换的对象调用函数。

后面五种是指针，有一个简便的办法记忆。从右往左读，遇到p就替换成“p is a ”遇到*就替换成“point to”



函数后面加 const表示函数不可以修改class的成员

```C++
char getData() const{         
		return this->letter;
}
```



##### 5.C和C++的区别：

（1）C语言是面向过程的程序设计语言，（C语言程序设计首要考虑的是如何通过一个过程，对输入进行运算处理得到输出；C++是面向对象的程序设计语言，C++语言程序设计首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程控制。C与C++最大的区别是解决问题的方法不一样。

（2）C++中允许通过定义类自定义数据类型，并支持继承、多态

（3）C++支持函数的重载，包括操作符的重载

（4）C++中可以定义引用类型

（5）C++中支持bool类型

（6）C语言当中通过malloc、free等函数申请和释放动态内存；C++当中通过new、delete申请和释放动态内存

（7）C++支持默认实参

（8）C++引入了命名空间的概念

##### 6.面向对象和面向过程的区别

（1）面向过程就是分析出解决问题所需要的步骤、过程，然后用函数将这些步骤和过程实现。

（2）面向对象是把构成问题的事务分解成各个对象，并且考虑如何建立对象模型

##### 7.面向过程与面向对象的优缺点：

面向过程：

优点：性能比面向对象高，因为类调用需要实例化，开销比较大，比较消耗资源，比如单片机、嵌入式开发、Linux/Uniux等一般采用面向过程开发，性能是最重要的因素。

缺点：没有面向对象易维护、易复用、易扩展

面向对象：

优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活，更加易于维护。

缺点：性能比面向过程低。

注：易维护体现在：

##### 8.指针的与数组的区别

（1）数组名是指向数组首元素的指针常量，指针可以是指针常量也可以是非指针常量；

（2）sizeof指针得到指针本身所占有的内存空间的大小，sizeof数组得到整个数组所占有的空间的大小；

（3）因为数组不能拷贝，所以无法以值传递的方式传递数组，函数也不能返回数组；但是，可以以值传递的方式传递指针，也可以从函数返回指针。

##### 9.浅拷贝和深拷贝

（1）浅拷贝：如果类的数据成员中函数指针，类的拷贝构造函数或者拷贝赋值运算符只拷贝类的指针的值。

（2）深拷贝：类的拷贝构造函数和拷贝赋值运算符，重新分配内存空间，拷贝指针所指的内容。

调用拷贝函数的情况：当使用类的一个对象去初始化该类的另一个新对象时。如果函数的形参是类的对象，那么当调用该函数时拷贝构造函数也会被调用。如果函数的返回值是类的对象，那么函数执行完成返回调用者时。

##### 10.构造函数能不能是虚函数

不能。原因如下

（1）虚函数通过虚函数表进行调用，类的每个对象中含有一个指向虚函数表的指针，这一指针在构造过程中被初始化，因此当对象没有被构造之前不能调用虚函数。如果构造函数是虚函数，也就没有办法调用构造函数了。

（2）虚函数作用是通过基类的指针或引用调用虚函数时发生动态绑定，但是构造函数是在创建对象时自动执行，不可能通过基类的指针或引用去调用，因此构造函数没有必要被定义为虚函数。

##### 11.虚函数存储在静态数据区

1.虚函数表是全局共享的元素,即全局仅有一个.

2.虚函数表类似一个数组,类对象中存储vptr指针,指向虚函数表.即虚函数表不是函数,不是程序代码,不肯能存储在代码段.

3.虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定,即虚函数表的大小可以确定,即大小是在编译时期确定的,不必动态分配内存空间存储虚函数表,所以不再堆中.

根据以上特征,虚函数表类似于类中静态成员变量.静态成员变量也是全局共享,大小确定.

所以我推测虚函数表和静态成员变量一样,存放在全局数据区.

 

c/c++程序所占用的内存一共分为五种:

栈区,堆区,程序代码区,全局数据区(静态区),文字常量区.

显而易见,虚函数表存放在全局数据区.

##### 12.构造函数、析构函数中能否抛出异常

（1）构造函数中尽量不抛出异常：构造函数中抛出异常，会导致析构函数不能被调用，因此可能会造成内存泄露或系统资源未被释放

（2）析构函数不应该抛出异常：因为函数在寻找异常处理代码的过程中退出，退出的过程中会调用析构函数销毁局部变量，如果析构函数也抛出异常，程序中也就有两个未经处理的异常，产生未定义的行为或者终止程序。

##### 13.在构造函数中抛出异常：

（1）在构造函数中抛出异常是C++中通知对象构造失败的唯一方法。

（2）构造函数中抛出异常，对象的析构函数将不会被执行。

（3）构造函数抛出异常，可能导致内存泄露、系统资源未被释放。

（4）当对象发生部分构造时，已经构造完毕的子对象将会被逆序地析构。

##### 14.智能指针

```C++
include <iostream>
using namespace std;

template<typename T>
class SharedPtr {
  private:
    T* m_ele;
    int* m_num;

  public:
    SharedPtr(): m_ele(nullptr){
        cout << "Hello Constructor 1 !" << endl;
        m_num = new int(0);
    }

    SharedPtr(T* x): m_ele(x){
        cout << "Hello Constructor 2 !" << endl;
        m_num = new int(1);
    }

    SharedPtr(const SharedPtr& x){
        cout << "Hello Copy Constructor !" << endl;
        m_ele = x.m_ele;
        m_num = x.m_num;
        (*m_num)++;
    }

 
    //当用一个shared_ptr<T> other去给另一个 shared_ptr<T> sp赋值时，发生了两件事情：

//一、sp指针指向发生变化，不再指向之前的内存区域，所以赋值前原来的_refCount要自减

//二、sp指针指向other.ptr，所以other的引用计数器_refCount要做++操作。


    SharedPtr& operator=(const SharedPtr& x){
        cout << "Copy Assignment !" << endl;
        (*m_num)--;
        if((*m_num) == 0){
            delete m_ele;
            delete m_num;
        }
        m_ele = x.m_ele;
        m_num = x.m_num;
        (*m_num)++;
        return *this;  //不是构造函数，要有返回值！
    }

    T&  operator*(){
        return *(this->m_ele);
    }

    T* operator->(){
        return this->m_ele;
    }

    ~SharedPtr(){
        cout << "Hello Destructor ! I'm " << *m_ele << endl;
        //调用析构函数，则其引用计数减1，若引用计数减为0，则将其封装的指针和计数指针都释放掉
        (*m_num)--;
        if((*m_num) == 0){
            delete m_ele;
            delete m_num;
        }
    }

    int useCount(){
        return *(this->m_num);
    }
};

```

