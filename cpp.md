[TOC]

##### 1.new和malloc的区别：

(1)  new是运算符，malloc是库函数

(2)  new会调用构造函数对对象进行初始化，malloc不会。

(3)  new申请分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显示地指出所需内存的尺寸。

(4)  new分配内存成功后返回指定的对象类型的指针，malloc返回void*。

(5)  new分配内存失败，会抛出bad_malloc异常，malloc分配内存失败会返回空指针。

new分配的内存通过delete释放，malloc分配的内存通过调用free()函数释放

##### 2.C语言程序能不能直接调用C++语言编写的动态链接库。

不能，因为C++支持重载，在编译函数的声明时，会改写函数名（可以通过链接指示进行解决）；另外，C语言不支持类，无法直接调用类的成员函数（可以通过加入中间层进行解决）；C语言也不能调用返回类型或形参类型是类类型的函数。

##### 3.关键字static的作用

（1）定义静态局部变量：在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。

（2）定义static全局变量：static全局变量仅在本文件内有效

（3）定义static函数：static函数仅在本文件内有效

（4）定义静态数据成员：静态成员数据成员与类本身相关联，而不是与类的各个对象保持关联。对象中不包含任何与静态数据成员有关的数据。

（5）定义静态成员函数：静态成员函数不与任何对象绑定在一起，它们不包含this指针。作为结果，静态成员函数不能声明成const的，而且我们也不能在static函数体内显式或隐式地使用this指针。

##### 4.const关键字的作用

（1）定义const对象，阻止变量的值被改变，const对象必须被初始化（因为它的值不能被改变）。

（2）定义常量引用，常量引用不能用于修改它所绑定的对象。

（3）定义常量指针，常量指针是指指针本身是常量，常量指针必须初始化，而且一旦初始化，则它的值就不能改变了。Const在*左边

（4）定义指向常量的指针，指向常量的指针不能用于改变它所指对象的值。

（5）定义const成员函数，常量对象，常量对象的引用或指针都只能调用常量成员函数。

（6）定义函数的形参为常量引用，表明函数不会修改实参的值，同时，也能使用const对象，字面值或者需要类型转换的对象调用函数。

后面五种是指针，有一个简便的办法记忆。从右往左读，遇到p就替换成“p is a ”遇到*就替换成“point to”



函数后面加 const表示函数不可以修改class的成员

```C++
char getData() const{         
		return this->letter;
}
```



##### 5.C和C++的区别：

（1）C语言是面向过程的程序设计语言，（C语言程序设计首要考虑的是如何通过一个过程，对输入进行运算处理得到输出；C++是面向对象的程序设计语言，C++语言程序设计首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程控制。C与C++最大的区别是解决问题的方法不一样。

（2）C++中允许通过定义类自定义数据类型，并支持继承、多态

（3）C++支持函数的重载，包括操作符的重载

（4）C++中可以定义引用类型

（5）C++中支持bool类型

（6）C语言当中通过malloc、free等函数申请和释放动态内存；C++当中通过new、delete申请和释放动态内存

（7）C++支持默认实参

（8）C++引入了命名空间的概念

##### 6.面向对象和面向过程的区别

（1）面向过程就是分析出解决问题所需要的步骤、过程，然后用函数将这些步骤和过程实现。

（2）面向对象是把构成问题的事务分解成各个对象，并且考虑如何建立对象模型

##### 7.面向过程与面向对象的优缺点：

面向过程：

优点：性能比面向对象高，因为类调用需要实例化，开销比较大，比较消耗资源，比如单片机、嵌入式开发、Linux/Uniux等一般采用面向过程开发，性能是最重要的因素。

缺点：没有面向对象易维护、易复用、易扩展

面向对象：

优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活，更加易于维护。

缺点：性能比面向过程低。

注：易维护体现在：

##### 8.指针的与数组的区别

（1）数组名是指向数组首元素的指针常量，指针可以是指针常量也可以是非指针常量；

（2）sizeof指针得到指针本身所占有的内存空间的大小，sizeof数组得到整个数组所占有的空间的大小；

（3）因为数组不能拷贝，所以无法以值传递的方式传递数组，函数也不能返回数组；但是，可以以值传递的方式传递指针，也可以从函数返回指针。

##### 9.浅拷贝和深拷贝

（1）浅拷贝：如果类的数据成员中函数指针，类的拷贝构造函数或者拷贝赋值运算符只拷贝类的指针的值。

（2）深拷贝：类的拷贝构造函数和拷贝赋值运算符，重新分配内存空间，拷贝指针所指的内容。

调用拷贝函数的情况：当使用类的一个对象去初始化该类的另一个新对象时。如果函数的形参是类的对象，那么当调用该函数时拷贝构造函数也会被调用。如果函数的返回值是类的对象，那么函数执行完成返回调用者时。

##### 10.构造函数能不能是虚函数

不能。原因如下

（1）虚函数通过虚函数表进行调用，类的每个对象中含有一个指向虚函数表的指针，这一指针在构造过程中被初始化，因此当对象没有被构造之前不能调用虚函数。如果构造函数是虚函数，也就没有办法调用构造函数了。

（2）虚函数作用是通过基类的指针或引用调用虚函数时发生动态绑定，但是构造函数是在创建对象时自动执行，不可能通过基类的指针或引用去调用，因此构造函数没有必要被定义为虚函数。

##### 11.虚函数存储在静态数据区

1.虚函数表是全局共享的元素,即全局仅有一个.

2.虚函数表类似一个数组,类对象中存储vptr指针,指向虚函数表.即虚函数表不是函数,不是程序代码,不肯能存储在代码段.

3.虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定,即虚函数表的大小可以确定,即大小是在编译时期确定的,不必动态分配内存空间存储虚函数表,所以不再堆中.

根据以上特征,虚函数表类似于类中静态成员变量.静态成员变量也是全局共享,大小确定.

所以我推测虚函数表和静态成员变量一样,存放在全局数据区.

 

c/c++程序所占用的内存一共分为五种:

栈区,堆区,程序代码区,全局数据区(静态区),文字常量区.

显而易见,虚函数表存放在全局数据区.

##### 12.构造函数、析构函数中能否抛出异常

（1）构造函数中尽量不抛出异常：构造函数中抛出异常，会导致析构函数不能被调用，因此可能会造成内存泄露或系统资源未被释放

（2）析构函数不应该抛出异常：因为函数在寻找异常处理代码的过程中退出，退出的过程中会调用析构函数销毁局部变量，如果析构函数也抛出异常，程序中也就有两个未经处理的异常，产生未定义的行为或者终止程序。

##### 13.在构造函数中抛出异常：

（1）在构造函数中抛出异常是C++中通知对象构造失败的唯一方法。

（2）构造函数中抛出异常，对象的析构函数将不会被执行。

（3）构造函数抛出异常，可能导致内存泄露、系统资源未被释放。

（4）当对象发生部分构造时，已经构造完毕的子对象将会被逆序地析构。

##### 14.智能指针

```C++
include <iostream>
using namespace std;

template<typename T>
class SharedPtr {
  private:
    T* m_ele;
    int* m_num;

  public:
    SharedPtr(): m_ele(nullptr){
        cout << "Hello Constructor 1 !" << endl;
        m_num = new int(0);
    }

    SharedPtr(T* x): m_ele(x){
        cout << "Hello Constructor 2 !" << endl;
        m_num = new int(1);
    }

    SharedPtr(const SharedPtr& x){
        cout << "Hello Copy Constructor !" << endl;
        m_ele = x.m_ele;
        m_num = x.m_num;
        (*m_num)++;
    }

 
    //当用一个shared_ptr<T> other去给另一个 shared_ptr<T> sp赋值时，发生了两件事情：

//一、sp指针指向发生变化，不再指向之前的内存区域，所以赋值前原来的_refCount要自减

//二、sp指针指向other.ptr，所以other的引用计数器_refCount要做++操作。


    SharedPtr& operator=(const SharedPtr& x){
        cout << "Copy Assignment !" << endl;
        (*m_num)--;
        if((*m_num) == 0){
            delete m_ele;
            delete m_num;
        }
        m_ele = x.m_ele;
        m_num = x.m_num;
        (*m_num)++;
        return *this;  //不是构造函数，要有返回值！
    }

    T&  operator*(){
        return *(this->m_ele);
    }

    T* operator->(){
        return this->m_ele;
    }

    ~SharedPtr(){
        cout << "Hello Destructor ! I'm " << *m_ele << endl;
        //调用析构函数，则其引用计数减1，若引用计数减为0，则将其封装的指针和计数指针都释放掉
        (*m_num)--;
        if((*m_num) == 0){
            delete m_ele;
            delete m_num;
        }
    }

    int useCount(){
        return *(this->m_num);
    }
};

```

​	shared_ptr允许多个指针指向同一个对象；unique_ptr则“独占”所指向的对象。weak_ptr是一种弱引用，指向shared_ptr所管理的对象。这三种类型都定义在memory头文件中。

​	**shared_ptr**都有一个关联的计数器，通常称为引用计数。无论何时我们拷贝一个shared_ptr，计数器都会递增。当我们给shared_ptr赋予一个新值或是shared_ptr被销毁时，计数器就会递减。

​	**unique_ptr**:独占它所指向的对象，某一时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁

​	**weak_ptr**:weak_ptr是一种不控制所指向对象生存期的智能指针，它指向一个shared_ptr管理的对象。使用weak_ptr可以用来阻止用户访问一个不再存在的对象的企图。

注:由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock。此函数检查weak_ptr指向的对象是否仍存在。如果存在，则返回一个指向共享对象的shared_ptr。如果不存在，则返回一个空的shared_ptr。

##### 15C++空类，默认产生哪些成员函数：

6个，默认构造函数、拷贝构造函数，拷贝赋值运算符、析构函数、取地址运算符和取地址运算符const。

##### 16.

RAII(Resource Acquisition Is Initialization)，也称为“资源获取就是初始化”，是C++语言的一种管理资源、避免泄露的惯用法。

##### 17.重载、重写和重定义的区别

（1）重载：函数名相同，参数列表不同

（2）重写：也称为覆盖，派生类覆盖基类的虚函数。函数名，参数列表必须相同，返回类型一般也必须相同，存在一个例外（当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。也就是说，如果D由B派生得到，则基类的虚函数可以返回B*而派生类的对应函数可以返回D*，只不过这样的返回类型要求从D到B的类型装换是可访问的）。

注：（1）静态函数不能被定义为虚函数，也不能被重载

（2）重写函数的访问修饰符可以不同

（3）重定义：也称为隐藏，派生类重新定义基类中有相同名称的非虚函数（有相同名称就可）

##### 18.虚函数可以是内联函数么？

可以，但是不会在调用点内联的展开，内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。

##### 19.态成员函数能否为虚函数？

静态成员函数不能是虚函数，静态成员函数与类相关联，而不是与类的对象相关联。静态成员函数不含有this指针，也就无法得到虚表指针，也就无法通过虚函数表调用虚函数。

##### 20.extern关键字

（1）用于变量、函数的声明：以标示变量或函数的定义在别的文件中

（2）用于链接指示：如果要在C++语言程序中调用C语言编写的函数，需要使用链接指示extern “C”对函数进行声明；通过链接指示对函数进行定义，可以导出C++函数到其他语言中。

（3）如果想在多个文件之间共享const对象，必须要在变量的定义之前添加extern关键字。

##### 21.strcpy和memcpy的区别：

（1）复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等

（2）复制的方法不同。strcpy不需要指定长度，而遇到被复制字的字符串结束符’\0’后结束；

memcpy则需要第3个参数指定要复制的长度。

（3）用途不同。通常在复制字符串时使用strcpy，而需要复制其他类型数据时则一般使用memcpy。

##### 22.malloc的底层实现

malloc函数将可用的内存块连接为一个空闲链表。调用malloc函数时，它沿着空闲链表寻找一个大到足以满足用户所需要的内存块。然后，将该内存块一分为二。一块分配给用户使用，另一个块重新连接到空闲链表。当用户申请一个大的内存片段，而内存块被切分为小的内存片段，无法满足用户的请求时，malloc函数请求延时，将相邻的小的空闲块合并成大的内存块。如果找不到合适的内存块，就通过系统调用brk，将break指针向高地址移动，获取新的内存块，连接到空闲链表中。另外，如果所申请的内存大于128k，调用mmap在文件映射区域找一块空闲的虚拟内存。如果分配内存失败，会返回NULL指针。

##### 23.C++内存对齐

（1）分配内存的顺序是按照声明的顺序

（2）每个变量相对起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍空出内存，直到偏移量是整数倍为止。

（3）最后整个结构体的大小必须是里面变量类型最大值的整数倍。

