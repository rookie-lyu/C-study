[TOC]

##### 1. 操作系统基本特征

1)  **并发**：并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。操作系统通过引入进程和线程，使得程序能够并发运行。

2)  **共享**：共享是指系统中的资源可以被多个并发进程共同使用。有两种共享方式：互斥共享和同时共享。互斥共享的资源称为临界资源，例如打印机等，在同一时间只允许一个进程访问，需要用同步机制来实现对临界资源的访问。

3)  **虚拟**：虚拟技术把一个物理实体转换为多个逻辑实体。主要有两种虚拟技术：时分复用和空分复用。多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占有处理器，每次只执行一个时间片并快速切换。虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。

4)  **异步**：进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。

##### 2.用户态和内核态之间的区别是什么呢？

权限不一样。用户态的进程能存取它们自己的指令和数据，但不能存取内核指令和数据或其他进程的指令和数据。核心态下的进程能够执行指令系统的全集，某些机器指令是特权指令，在用户态下执行特权指令会引起错误。

##### 3. **中断分类**

1)  **外中断**：由CPU执行指令以外的事件引起，如I/O完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。

2)  **异常**：由CPU执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。

3)  **陷入**：在用户程序中使用系统调用。

##### 4. 进程和线程，有什么区别？

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位. 

线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 

**关系**

1)  一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程是操作系统可识别的最小执行和调度单位；

2)  资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量；

3)  处理机分给线程，即真正在处理机上运行的是线程；

4)  线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步；

**区别：**

1)  **拥有资源**：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源；

```C++
栈和程序计数器用来保存线程的执行历史和线程的执行状态，是线程私有的资源。其他的资源（比如堆、地址空间、全局变量）是由同一个进程内的多个线程共享
```

2)  **调度**：线程是独立调度的基本单位，在同一进程中，线程切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换；

3)  **系统开销**：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程CPU环境的保存及新调度进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小；

4)  **通信方面：**线程间可以通过直接读写同一进程中的共享数据进行通信，但是进程通信需要借助IPC；

5)  **健壮性：**一个进程挂掉了不会影响其他进程，而线程挂掉了会影响其他线程；

##### 5.线程分类

**用户级线程**：对于这类线程，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。在应用程序启动后，操作系统分配给该程序一个进程号，以及其对应的内存空间等资源。应用程序通常先在一个线程中运行，该线程被成为主线程。在其运行的某个时刻，可以通过调用线程库中的函数创建一个在相同进程中运行的新线程。用户级线程的好处是非常高效，不需要进入内核空间，但并发效率不高。

**内核级线程**：对于这类线程，有关线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只能调用内核线程的接口。内核维护进程及其内部的每个线程，调度也由内核基于线程架构完成。内核级线程的好处是，内核可以将不同线程更好地分配到不同的CPU，以实现真正的并行计算。

##### 6.调度分类

**高级调度：**作业调度，它决定把后备作业调入内存运行；

**中级调度：**内存调度，在内、外存对换区进行进程对换。

**低级调度：**进程调度，它决定让就绪队列的某进程获得CPU；

**非抢占式调度与抢占式调度**

**非抢占式**：分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生进程调度某事件而阻塞时，才把处理机分配给另一个进程。

**抢占式**：操作系统将正在运行的进程强行暂停，由调度程序将CPU分配给其他就绪进程的调度方式。

##### 7.进程状态切换

1)  就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源；

2)  运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数；

3)  阻塞状态：进程等待某种条件，在条件满足之前无法执行；

![jincheng](C:\Users\wsgbcsc\Desktop\image\jincheng.jpg))

##### 8. 进程调度策略

1)  FCFS(先来先服务，队列实现，非抢占的)：先请求CPU的进程先分配到CPU

2)  SJF(最短作业优先调度算法)：平均等待时间最短，但难以知道下一个CPU区间长度

3)  优先级调度算法(可以是抢占的，也可以是非抢占的)：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿

4)  时间片轮转调度算法(可抢占的)：队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。而如果时间片过长，会退化为FCFS。

5)  多级队列调度算法：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。

6)  多级反馈队列调度算法：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。

7)高响应占比调度算法

##### 9. 上下文切换

​	对于单核单线程CPU而言，在某一时刻只能执行一条CPU指令。上下文切换是一种将CPU资源从一个进程分配给另一个进程的机制。计算机能够并行运行多个进程是操作系统通过快速上下文切换造成的结果。在切换的过程中，操作系统需要先存储当前进程的状态(包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。

##### 10. 为什么进程切换比线程切换代价高？

进程切换分两步：

1.切换页目录以使用新的地址空间

2.切换内核栈和硬件上下文

线程和进程的最大区别就在于地址空间，对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。

##### 11. 临界资源

对于某些资源来说，其在同一时间只能被一个进程所占用。这些**一次只能被一个进程所占用的资源**就是所谓的临界资源。典型的临界资源比如物理上的打印机，或是存在硬盘或内存中被多个进程所共享的一些变量和数据等(如果这类资源不被看成临界资源加以保护，那么很有可能造成丢数据的问题)。

对于临界资源的访问，必须是互斥进行。也就是当临界资源被占用时，另一个申请临界资源的进程会被阻塞，直到其所申请的临界资源被释放。而进程内访问临界资源的代码被成为临界区。

##### 12. 多线程与多进程

|  **对比维度**  | **多进程**                                                   | **多线程**                                                   | **总结** |
| :------------: | :----------------------------------------------------------- | ------------------------------------------------------------ | -------- |
| 数据共享、同步 | 数据共享复杂，需要用IPC；  数据是分开的，同步简单            | 因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂 | 各有优势 |
|   内存、CPU    | 占用内存多，切换复杂，CPU利用率低                            | 占用内存少，切换简单，CPU利用率高                            | 线程占优 |
| 创建销毁、切换 | 创建销毁、切换复杂，速度慢                                   | 创建销毁、切换简单，速度很快                                 | 线程占优 |
|   编程、调试   | 编程简单，调试简单                                           | 编程复杂，调试复杂                                           | 进程占优 |
|     可靠性     | 进程间不会互相影响                                           | 一个线程挂掉将导致整个进程挂掉                               | 进程占优 |
|     分布式     | 适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单 | 适应于多核分布式                                             | 进程占优 |

1）需要频繁创建销毁的优先用线程**

这种原则最常见的应用就是Web服务器了，来一个连接建立一个线程，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的

2）需要进行大量计算的优先使用线程**

所谓大量计算，要耗费很多CPU，切换频繁了，这种情况下线程是最合适的。

3）强相关的处理用线程，弱相关的处理用进程**

一般的Server需要完成如下任务：消息收发、消息处理。“消息收发”和“消息处理”就是弱相关的任务，而“消息处理”里面可能又分为“消息解码”、“业务处理”，这两个任务相对来说相关性就要强多了。因此“消息收发”和“消息处理”可以分进程设计，“消息解码”、“业务处理”可以分线程设计。

当然这种划分方式不是一成不变的，也可以根据实际情况进行调整。

4）可能要扩展到多机分布的用进程，多核分布的用线程**

##### **13.** 进程同步与互斥

同步：多个进程按一定顺序执行；

互斥：多个进程在同一时刻只有一个进程能进入临界区。

同步机制遵循的原则：

空闲让进：临界区空闲时，允许一个进程立即进入临界区

忙则等待：保证对临界区的互斥访问

有限等待：有限代表有限的时间，避免死等

 让权等待：当进程不能进入自己的临界区时，应该释放处理机，以免陷入忙等状态。

##### 14. 同步和异步*

**同步**：是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么，这个进程将会一直等待下去，直到收到返回信息才继续执行下去。

1)  同步是阻塞模式；

2)  同步是按顺序执行，执行完一个再执行下一个，需要等待，协调运行；

**异步：**是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。

1)  异步是非阻塞模式，无需等待；

2)  异步是彼此独立，在等待某事件的过程中，继续做自己的事，不需要等待这一事件完成后再工作。线程是异步实现的一个方式。

**优缺点：**

同步可以避免出现死锁，读脏数据的发生。一般共享某一资源的时候，如果每个人都有修改权限，同时修改一个文件，有可能使一个读取另一个人已经删除了内容，就会出错，同步就不会出错。但，同步需要等待资源访问结束，浪费时间，效率低。

异步可以提高效率，但，安全性较低。

##### 15. 进程通信

**管道（pipe）：**管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。

(1) 它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。

(2) 它只能用于具有亲缘关系的进程之间的通信（父子进程或者兄弟进程之间）。

(3) 它可以看成是一种特殊的文件，对它的读写可以使用普通的read、write 等函数。但它不是普通的文件，不属于任何文件系统，只存在于内存中。

当一个管道建立时，它会创建两个文件描述符：fd[0]为读而打开，fd[1]为写而打开，要关闭管道只需将这两个文件描述符关闭即可，如下图：

单个进程中的管道几乎没有任何用处。所以，通常调用 pipe 的进程接着调用 fork，这样就创建了父进程与子进程之间的 IPC 通道。

**命名管道**：FIFO，它是一种文件类型。

(1) FIFO可以在无关的进程之间交换数据，与无名管道不同。

(2) FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。

FIFO的通信方式类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时清除数据，并且“先进先出”。

**消息队列**：消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。

(1) 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。

(2) 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容不会被删除。

(3) 消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。

**信号量**：信号量是一个计数器，用于实现进程间的互斥与同步，而不是用于存储进程间的通信数据。

(1) 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。

(2) 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。

(3) 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，可以加减任意正整数。

(4) 支持信号量组。

**共享存储**：指两个或多个进程共享一个给定的存储区。

(1) 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。

(2) 因为多个进程可以同时操作，所以需要进行同步。

(3) 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。

Eg:实际操作中对应的是“剪贴板”（剪贴板实际上是系统维护管理的一块内存区域）的通信方式，比如举例如下：word进程按下ctrl+c，在ppt进程按下ctrl+v，即完成了word进程和ppt进程之间的通信，复制时将数据放入到剪贴板，粘贴时从剪贴板中取出数据，然后显示在ppt窗口上。

**Socket**：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。

**几种方式比较**

1.管道：速度慢，容量有限，只有父子进程能通讯   

2.FIFO：任何进程间都能通讯，但速度慢   

3.消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题   

4.信号量：不能传递复杂消息，只能用来同步   

5.共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。

##### 16. 线程同步

线程间通信的目的主要用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。

1)  **互斥量** Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问

2)  **信号量**：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量

3)  **事件(信号)**，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

##### 17. 多线程并发会引发的问题

**安全性问题**：在单线程系统上正常运行的代码，在多线程环境中可能会出现意料之外的结果。

**活跃性问题**：不正确的加锁、解锁方式可能会导致死锁or活锁问题。

**性能问题**：多线程并发即多个线程切换运行，线程切换会有一定的消耗并且不正确的加锁。

##### 18. 逻辑地址与物理地址

所谓的逻辑地址，是指计算机用户看到的地址。例如，当创建一个长度为100的整型数组时，操作系统返回一个逻辑上的连续空间：指针指向数组第一个元素的内存地址。由于整型元素的大小为4个字节，故第二个元素的地址时起始地址加4，以此类推。事实上，逻辑地址并不一定是元素存储的真实地址，即数组元素的物理地址(在内存条中所处的位置)，并非是连续的，只是操作系统通过地址映射，将逻辑地址映射成连续的，这样更符合人们的直观思维。

最高10位 Directory 页目录表偏移量，中间10位 Table是页表偏移量，最低12位Offset是物理页内的字节偏移量线性地址 0x80495b0 转换成二进制后是 0000 1000 0000 0100 1001 0101 1011 0000，最高10位0000 1000 00的十进制是32，CPU查看页目录表第32项，里面存放的是页表的物理地址。线性地址中间10位00 0100 1001 的十进制是73，页表的第73项存储的是最终物理页的物理起始地址。物理页基地址加上线性地址中最低12位的偏移量，CPU就找到了线性地址最终对应的物理内存单元。

##### 19. 虚拟内存

虚拟内存允许执行进程不必完全在内存中。虚拟内存的基本思想是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到不在物理内存中的地址空间时，会产生缺页中断，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。

##### 20. 虚拟内存的优点

虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。虚拟内存的使用可以带来以下好处：

·     在内存中可以保留多个进程，系统并发度提高

·     解除了用户与内存之间的紧密约束，进程可以比内存的全部空间还大

各进程的地址空间安全性得到了提高

##### 21. 页面置换算法

FIFO先进先出算法： 

LRU最近最少使用算法：根据使用时间到现在的长短来判断；

LFU最少使用次数算法：根据使用次数来判断；

OPT最优置换算法：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。